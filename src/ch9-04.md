## ë¼ì´í”„íƒ€ì„ê³¼ ìŠ¤íƒœí‹±

ë ˆí¼ëŸ°ìŠ¤ ê·¸ë¦¬ê³  ì†Œìœ ê¶Œ ëŒ€ì—¬ ê·œì¹™ì—ì„œ ë‹¤ë£¨ì§€ ì•Šì€ í•œ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤. ë°”ë¡œ ëŸ¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ë ˆí¼ëŸ°ìŠ¤ëŠ” ìœ íš¨í•œ ë²”ìœ„ì¸ ë¼ì´í”„íƒ€ì„ì´ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ê²½ìš°, ë ˆí¼ëŸ°ìŠ¤ì˜ ë¼ì´í”„íƒ€ì„ì€ ë³€ìˆ˜ì˜ íƒ€ì…ì´ ì¶”ë¡ ë˜ëŠ” ê²ƒê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ëŒ€ë¶€ë¶„ì˜ ìƒí™©ì—ì„œ ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ë¡  ê°€ëŠ¥í•©ë‹ˆë‹¤.



### ë¼ì´í”„íƒ€ì„(lifetime)

í•˜ì§€ë§Œ ëª‡ëª‡ ìƒí™©ì˜ ê²½ìš°, ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì–´ë–¤ ë ˆí¼ëŸ°ìŠ¤ê°€ ì–¸ì œê¹Œì§€ ìœ íš¨(living)í•œê°€ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤˜ì•¼ í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì•„ë˜ì™€ ê°™ì€ ê²½ìš°ëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}

```

ë‚´ë¶€ ìŠ¤ì½”í”„ì—ì„œ ì°¸ì¡°ëœ `x`ê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ ê°’ì´ ì‚­ì œë˜ê¸° ë•Œë¬¸ì— `r`ì´ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ê°’ì´ ì—†ëŠ” ìƒíƒœê°€ ë©ë‹ˆë‹¤. ì´ëŸ¬í•œ ê²½ìš°ë¥¼ ëŒ•ê¸€ë§ ë ˆí¼ëŸ°ìŠ¤(Dangling reference)ë¼ê³  í•©ë‹ˆë‹¤.

ì•„ì‰½ê²Œë„ ë³€ìˆ˜ì— ë¼ì´í”„íƒ€ì„ì„ ì¶”ê°€í•˜ëŠ” ë¬¸ë²•ì€ ì•„ì§ ëŸ¬ìŠ¤íŠ¸ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  í•¨ìˆ˜ì—ì„œ íŒŒë¼ë¯¸í„°ì™€ ë¦¬í„´ ê°’ì˜ ë¼ì´í”„íƒ€ì„ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.



### í•¨ìˆ˜ì—ì„œì˜ ë¼ì´í”„íƒ€ì„



```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```


ì‹¤í–‰ ê²°ê³¼

 ```
 error[E0106]: missing lifetime specifier
  --> src/main.rs:9:33
   |
 9 | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
 help: consider introducing a named lifetime parameter
   |
 9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
   |           ++++     ++          ++          ++
 
 ```


ì´ í•¨ìˆ˜ê°€ `x` í˜¹ì€ `y` ì¤‘ ì–´ë–¤ ê°’ì„ ë¦¬í„´í•  ì§€ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¦‰ `x`ì™€ `y`ê°€ ì–¸ì œê¹Œì§€ ìŠ¤ì½”í”„ì—ì„œ ìœ íš¨í•œì§€ë¥¼ ì•Œ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ë¦¬í„´ë˜ëŠ” ìŠ¤íŠ¸ë§ ìŠ¬ë¼ì´ìŠ¤ ì—­ì‹œ ì–¸ì œê¹Œì§€ ìœ íš¨í•œì§€ë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë¦¬í„´ë˜ëŠ” ê°’ì´ ì–¸ì œê¹Œì§€ ìœ íš¨í•œì§€ë¥¼ ì•Œë ¤ì¤˜ì•¼ í•©ë‹ˆë‹¤.

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

ì´ ê·œì¹™ì— ë”°ë¼ `longest`ì— ë¼ì´í”„íƒ€ì„ì„ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```



> ë¼ì´í”„íƒ€ì„ì— ëŒ€í•´ì„œ ê¸°ì–µí•´ì•¼ í•  ê°€ì¥ ì¤‘ìš”í•œ ì ì€ "ë¼ì´í”„íƒ€ì„ í‘œê¸°ëŠ” ë ˆí¼ëŸ°ìŠ¤ì˜ ì‹¤ì œ ë¼ì´í”„íƒ€ì„ì„ ë°”ê¾¸ì§€ ì•ŠëŠ”ë‹¤" ë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ì—¬ëŸ¬ ë ˆí¼ëŸ°ìŠ¤ì˜ ë¼ì´í”„íƒ€ì„ ì‚¬ì´ì˜ ê´€ê³„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. 



ì´ë²ˆì—ëŠ” ì„œë¡œ ë‹¤ë¥¸ ë¼ì´í”„íƒ€ì„ì„ ê°–ëŠ” `string1`ê³¼ `string2`ë¥¼ ì‚¬ìš©í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str()); // ğŸ¤¯
    }
    println!("The longest string is {}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```

`string2`ì˜ ë ˆí¼ëŸ°ìŠ¤ê°€ ìŠ¤ì½”í”„ ì•ˆì—ì„œë§Œ ìœ íš¨í•˜ê¸° ë•Œë¬¸ì— ì´ì™€ ê°™ì€ ë¼ì´í”„íƒ€ì„ì„ ê°–ëŠ” `result`ëŠ” ìŠ¤ì½”í”„ ë°–ì—ì„œ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì–´ì°Œë˜ì—ˆë“  ìœ íš¨í•œ ì†Œìœ ê¶Œ ê·œì¹™ì„ ì§€í‚¤ê¸° ìœ„í•´ì„œ ì„œë¡œ ë‹¤ë¥¸ ë¼ì´í”„íƒ€ì„ì„ ëª…ì‹œí•˜ê³ , ê°€ì¥ ì˜¤ë˜ ì‚´ì•„ë‚¨ëŠ” `x`ë§Œ ë¦¬í„´í•˜ë„ë¡ í•˜ë©´ ì½”ë“œë¥¼ ë™ì‘í•˜ê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str()); // ğŸ¤¯
    }
    println!("The longest string is {}", result);
}

fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        "y is no use here ğŸ¥²"
    }
}
```



### ìŠ¤íƒœí‹±(static) ë¼ì´í”„íƒ€ì„

í•œ ê°€ì§€ íŠ¹ë³„í•œ ë¼ì´í”„íƒ€ì„ì´ ìˆìŠµë‹ˆë‹¤. ë°”ë¡œ `static`ìœ¼ë¡œ, í•´ë‹¹ ë ˆí¼ëŸ°ìŠ¤ê°€ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ê³„ì†í•´ì„œ ì¡´ì¬í•  ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ëª¨ë“  ë¬¸ìì—´ ë¦¬í„°ëŸ´ì€ ìŠ¤íƒœí‹± ë¼ì´í”„íƒ€ì„ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.

```rust
let s: &'static str = "Long live the static!";
```


ì´ ë¬¸ìì—´ì˜ ê°’ì€ í”„ë¡œê·¸ë¨ì˜ ë°”ì´ë„ˆë¦¬ì— ì§ì ‘ ì €ì¥ë˜ì–´ í•­ìƒ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ëª¨ë“  ë¬¸ìì—´ ë¦¬í„°ëŸ´ì˜ ìˆ˜ëª…ì€ ìŠ¤íƒœí‹±ì…ë‹ˆë‹¤.



ì°¸ê³ ë¡œ, ë¬¸ìì—´ ê´€ë ¨ ì½”ë“œë¥¼ ì‘ì„±í•˜ë‹¤ê°€ ë ˆí¼ëŸ°ìŠ¤ ê´€ë ¨ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ ì˜¤ë¥˜ ë©”ì‹œì§€ì—ì„œ ìŠ¤íƒœí‹± ë¼ì´í”„íƒ€ì„ì„ ì‚¬ìš©í•˜ë¼ëŠ” ì»´íŒŒì¼ëŸ¬ì˜ ì œì•ˆì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë¼ì´í”„íƒ€ì„ì€ ë¬¸ìì—´ì˜ ì¡´ì¬ ê¸°ê°„ì„ ëª…í™•í•˜ê²Œ ëª…ì‹œí•˜ëŠ” ìš©ë„ì´ê¸° ë•Œë¬¸ì— ë°”ë¡œ ìŠ¤íƒœí‹± ë¼ì´í”„íƒ€ì„ì„ ì‚¬ìš©í•˜ì§€ ë§ê³ , ì´ ë¬¸ìì—´ì˜ ì •í™•í•œ ë¼ì´í”„íƒ€ì„ì„ ë¨¼ì € ì ìš©í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.



