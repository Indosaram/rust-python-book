## ì œë„¤ë¦­ê³¼ íŠ¸ë ˆì´íŠ¸





### `impl Trait` 

`impl Trait` can be used in two locations:

1. as an argument type
2. as a return type



#### íŒŒë¼ë¯¸í„° íƒ€ì…

If your function is generic over a trait but you don't mind the specific type, you can simplify the function declaration using `impl Trait` as the type of the argument.

```rust
fn copy(_item: impl Copy) {
    println!("Copy");
}

fn clone(_item: impl Clone) {
    println!("Clone");
}

fn main() {
    let num = 1;
    copy(num);
    clone(num);

    let string = String::from("Hello");
    clone(string);
    // copy(string); // ğŸ¤¯
}

```









### íŠ¸ë ˆì´íŠ¸ ë°”ìš´ë“œ

íŠ¸ë ˆì´íŠ¸ ë°”ìš´ë“œ(Trait bound)ë€ `impl Trait` ë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹  ì¢€ë” ê°„ê²°í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```rust
use std::fmt::Display;

fn some_function<T: Display>(t: &T) {
    println!("{}", t);
}

fn main() {
    let x = 5;
    some_function(&x);
}

```

ì´ë¥¼ ì›ë˜ëŒ€ë¡œ `impl Trait`ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```rust
fn some_function(t: &impl Display) {
    println!("{}", t);
}
```

íŠ¸ë ˆì´íŠ¸ ë°”ìš´ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ íƒ€ì…ì„ ë³µí•©ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) {}
```

í•˜ì§€ë§Œ ì´ëŸ¬ë©´ í•¨ìˆ˜ ì„ ì–¸ì„ ì•Œì•„ë³´ê¸°ê°€ ì–´ë ¤ì›Œì§€ê¸° ë•Œë¬¸ì— `where` ë¬¸ì„ ì‚¬ìš©í•´ ì¢€ë” ì½ê¸° ì‰½ê²Œ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust,ignore
use std::fmt::{Debug, Display};

fn some_function<T, U>(t: &T, u: &U)
where
    T: Display + Clone,
    U: Clone + Debug,
{
    println!("{} {:?}", t, u);
}

fn main() {
    let x = 5;
    let y = vec![1, 2, 3];
    some_function(&x, &y);
}

```











#### ë¦¬í„´ íƒ€ì…

ë¦¬í„´ íƒ€ì…ìœ¼ë¡œ `impl Trait` êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ë©´ íŠ¹ì • íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•˜ê³  ìˆëŠ” íƒ€ì…ì„ ë¦¬í„´í•˜ë„ë¡ í— ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:

```rust
fn double(vector: Vec<i32>) -> impl Iterator<Item = i32> {
    vector.into_iter().map(|x| x * 2)
}

fn main() {
    for num in double(vec![1, 2, 3]) {
        println!("{}", num);
    }
}

```







### í„°ë³´í”¼ì‹œ

í„°ë³´ í”¼ì‰¬ ì‹ íƒìŠ¤ëŠ” ì œë„¤ë¦­ íƒ€ì…ì¸ íŒŒë¼ë¯¸í„°ì— êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì§€ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```rust,ignore
identifier::<type>
```



#### íƒ€ì… ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹ ì— ì‚¬ìš©ë˜ëŠ” ê²½ìš°

ê°„ê²°ì„±ì„ ìœ„í•´ ëª…ì‹œì  íƒ€ì… ì–´ë…¸í…Œì´ì…˜ ëŒ€ì‹ ì— ì‚¬ìš©ë©ë‹ˆë‹¤.



ì»´íŒŒì¼ëŸ¬ê°€ ëŒ€ë¶€ë¶„ì˜ ìƒí™©ì—ì„œ íƒ€ì…ì„ ì¶”ë¡  ê°€ëŠ¥

```rust
use std::collections::HashMap;

fn main() {
    let mut students = HashMap::new();
    students.insert("buzzi", 100);
}

```



ì´ëŸ° ê²½ìš°ëŠ” ì–´ë–¤ ì›ì†Œë¥¼ ë„£ëŠ”ì§€ ì•Œ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤˜ì•¼ í•¨

```rust
use std::collections::HashMap;

fn main() {
    let mut students: HashMap<&str, i32> = HashMap::new();
    // students.insert("buzzi", 100);
}

```



ì´ ê²½ìš° í„°ë³´í”¼ì‹œë¥¼ ì‚¬ìš©í•´ì„œ íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì„ ëŒ€ì²´ ê°€ëŠ¥

```rust
use std::collections::HashMap;

fn main() {
    let mut students: HashMap = HashMap::<&str, i32>::new();
    // students.insert("buzzi", 100);
}

```





ë³µì¡í•œ ì˜ˆì œ

```rust
fn double<T>(vector: Vec<T>) -> impl Iterator<Item = T> {
    vector.into_iter().map(|x| x)
}

fn main() {
    let nums = double(vec![1, 2, 3]).collect::<Vec<i32>>();
    println!("{:?}", nums);
    let nums: Vec<String> =
        double(vec!["1".to_string(), "2".to_string(), "3".to_string()]).collect();
    println!("{:?}", nums);
}
```



#### ëª…ì‹œì  íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì´ ì‘ë™í•˜ì§€ ì•Šì„ ë•Œ

```rust
fn main() {
    let nums: Vec<i32> = ["1", "2", "three"]
        .iter()
        .filter_map(|x| x.parse().ok())
        .collect();
}

```



```rust,ignore
fn main() {
    let nums: bool = ["1", "2", "three"]
        .iter()
        .filter_map(|x| x.parse().ok())
        .collect() // ğŸ¤¯
        .contains(&1);
}

```



```rust
fn main() {
    let nums: bool = ["1", "2", "three"]
        .iter()
        .filter_map(|x| x.parse().ok())
        .collect::<Vec<i32>>()
        .contains(&1);
}

```

