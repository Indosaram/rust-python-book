## ë©”ëª¨ë¦¬ ê³µìœ 



## ìŠ¤ë ˆë“œ ì†Œìœ ê¶Œê³¼ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…

ì§€ê¸ˆê¹Œì§€ ê°ì²´ì˜ ì†Œìœ ê¶Œì„ `move` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ í´ë¡œì €ë¡œ ë„˜ê¸°ê±°ë‚˜, ë²”ìœ„ ì œí•œ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤. ë‘ ìŠ¤ë ˆë“œê°€ ë°ì´í„°ë¥¼ ê³µìœ í•˜ëŠ” ìƒí™©ì—ì„œ, ë‘ ìŠ¤ë ˆë“œ ëª¨ë‘ê°€ ë‚˜ë¨¸ì§€ í•˜ë‚˜ë³´ë‹¤ ë” ì˜¤ë˜ ì¡´ì¬í•œë‹¤ëŠ” ì‚¬ì‹¤ì´ ë³´ì¥ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ì–´ë–¤ ìŠ¤ë ˆë“œë„ ë°ì´í„°ì˜ ì†Œìœ ê¶Œì„ ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê³µìœ ë˜ëŠ” ì–´ë–¤ ë°ì´í„°ë„ ë‘ ìŠ¤ë ˆë“œë³´ë‹¤ ë” ì˜¤ë˜ ì¡´ì¬í•´ì•¼ë§Œ í•©ë‹ˆë‹¤.



### ìŠ¤íƒœí‹±(static)

ëŸ¬ìŠ¤íŠ¸ì—ëŠ” ì–´ë– í•œ ìŠ¤ë ˆë“œì—ë„ ì†Œì†ë˜ì§€ ì•ŠëŠ” ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì´ ìˆëŠ”ë°, ë°”ë¡œ `static`ì…ë‹ˆë‹¤. `static` ë³€ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ ìì²´ê°€ ì†Œìœ ê¶Œì„ ê°€ì§€ê¸° ë•Œë¬¸ì— ë°˜ë“œì‹œ ì–´ë–¤ ìŠ¤ë ˆë“œë³´ë‹¤ë„ ì˜¤ë˜ ì¡´ì¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì˜ˆì œì—ì„œëŠ” ë‘ ìŠ¤ë ˆë“œ ëª¨ë‘ `X`ì— ì ‘ê·¼í•  ìˆ˜ ìˆì§€ë§Œ, ë‘ ìŠ¤ë ˆë“œ ëª¨ë‘ `X`ë¥¼ ì†Œìœ í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.

```rust
static X: [i32; 3] = [1, 2, 3];
thread::spawn(|| dbg!(&X));
thread::spawn(|| dbg!(&X));
```

`static`ìœ¼ë¡œ ì„ ì–¸ëœ ë³€ìˆ˜ëŠ” ìƒìˆ˜ ê°’ì„ ê°€ì§€ë©°, í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë˜ê¸° ì „ì— ìƒì„±ë©ë‹ˆë‹¤. ë”°ë¼ì„œ ì–´ë–¤ ìŠ¤ë ˆë“œë„ `static` ë³€ìˆ˜ë¡œë¶€í„° ê°’ì„ ë¹Œë ¤ì˜¬ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.



### ìœ ì¶œ(Leaking)

ë˜ ë‹¤ë¥¸ ë°ì´í„° ê³µìœ  ë°©ë²•ì€ ê°’ì˜ í• ë‹¹ì„ ìœ ì¶œì‹œí‚¤ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. `Box::leak` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ `Box`ì˜ ì†Œìœ ê¶Œì„ í•´ì œí•˜ê³  ì ˆëŒ€ ì´ ê°’ì´ ì‚­ì œë˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œë¶€í„° `Box`ëŠ” í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ë•Œê¹Œì§€ ì¡´ì¬í•˜ê²Œ ë˜ê³  ì–´ëŠ ìŠ¤ë ˆë“œì—ì„œë„ ê°’ì„ ë¹Œë ¤ ê°ˆ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

```rust
let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));

thread::spawn(move || dbg!(x));
thread::spawn(move || dbg!(x));
```

ì—¬ê¸°ì„œ `move` í´ë¡œì €ê°€ ê°’ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ê°€ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì´ì§€ë§Œ, ìì„¸íˆ ì‚´í´ë³´ë©´ `x`ëŠ” ë‹¨ìˆœíˆ ì›ë˜ `Box`ì˜ ë ˆí¼ëŸ°ìŠ¤ë¼ëŠ” ì‚¬ì‹¤ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ë ˆí¼ëŸ°ìŠ¤ë€ ì •ìˆ˜í˜•ì´ë‚˜ ë¶ˆë¦¬ì–¸ íƒ€ì…ì²˜ëŸ¼ ì›ë³¸ ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œ ë‘ê³  ê°’ë§Œ ë³µì‚¬í•´ê°€ëŠ” ê²ƒì…ë‹ˆë‹¤.

ì—¬ê¸°ì„œ ì£¼ì˜í•´ì•¼ í•  ì ì€ `'static` ìœ¼ë¡œ ì„ ì–¸ë˜ì—ˆë‹¤ê³  í•´ì„œ ì´ ê°’ì´ í”„ë¡œê·¸ë¨ ì‹œì‘ ì „ì— ë§Œë“¤ì–´ì§„ë‹¤ëŠ” ê²ƒì€ ì•„ë‹ˆë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ì¤‘ìš”í•œ ì ì€ ì´ ê°’ì´ í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ë•Œê¹Œì§€ ìœ ì§€ëœë‹¤ëŠ” ì‚¬ì‹¤ì…ë‹ˆë‹¤.

ì´ë ‡ê²Œ `Box`ë¥¼ ìœ ì¶œì‹œí‚¤ê²Œ ë˜ë©´ ë©”ëª¨ë¦¬ê°€ ìœ ì¶œë˜ëŠ” ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤. ë©”ëª¨ë¦¬ì— ì–´ë–¤ ê°ì²´ë¥¼ í• ë‹¹í–ˆì§€ë§Œ, ê°ì²´ë¥¼ ì‚­ì œí•˜ê³  ë©”ëª¨ë¦¬ì—ì„œ í• ë‹¹ í•´ì œí•˜ì§€ ì•ŠëŠ” ê²ƒì…ë‹ˆë‹¤. ì „ì²´ í”„ë¡œê·¸ë¨ì—ì„œ ì´ëŸ¬í•œ íŒ¨í„´ì´ ëª‡ ë²ˆ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ í° ìƒê´€ì´ ì—†ì§€ë§Œ, ì´ëŸ¬í•œ íŒ¨í„´ì´ ë°˜ë³µë˜ë©´ í”„ë¡œê·¸ë¨ì˜ ë©”ëª¨ë¦¬ê°€ ì ì°¨ ë¶€ì¡±í•´ì§ˆ ê²ƒì…ë‹ˆë‹¤.



### ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…

ìŠ¤ë ˆë“œ ì‚¬ì´ì—ì„œ ê³µìœ ëœ ë°ì´í„°ê°€ í™•ì‹¤íˆ ì‚­ì œë˜ê³  ë©”ëª¨ë¦¬ì—ì„œ í• ë‹¹ í•´ì œë˜ê²Œ í•˜ë ¤ë©´, í•´ë‹¹ ë°ì´í„°ì˜ ì†Œìœ ê¶Œì„ í¬ê¸°í•´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤. ëŒ€ì‹ , *ì†Œìœ ê¶Œì„ ê³µìœ *í•˜ë©´ ê°€ëŠ¥í•©ë‹ˆë‹¤. í•´ë‹¹ ë°ì´í„°ì˜ ì†Œìœ ìë“¤ì„ ì§€ì†ì ìœ¼ë¡œ ê´€ë¦¬í•¨ìœ¼ë¡œì¨ ë” ì´ìƒ í•´ë‹¹ ë°ì´í„°ì˜ ì†Œìœ ìê°€ ì—†ì„ ë•Œ ê°ì²´ë¥¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ë°©ë²•ì„ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…(Reference counting)ì´ë¼ê³  í•˜ê³ , ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” `std::rc::Rc` íƒ€ì…ì„ ì‚¬ìš©í•´ êµ¬í˜„ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. `Box`ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ê²Œ ë˜ë©´ ìƒˆë¡œìš´ ë°ì´í„°ê°€ ë©”ëª¨ë¦¬ì— í• ë‹¹ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆê³  ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ì˜ ê°’ì´ ì¦ê°€í•©ë‹ˆë‹¤. ê²°ë¡ ì ìœ¼ë¡œ ì›ë³¸ ë°ì´í„°ì™€ ë³µì‚¬ëœ ë°ì´í„° ëª¨ë‘ ê°™ì€ ë©”ëª¨ë¦¬ì— í• ë‹¹ëœ ê°’ì„ ì°¸ì¡°í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì›ë¦¬ ë•Œë¬¸ì— ì†Œìœ ê¶Œì„ ê³µìœ í•œë‹¤ê³  ë§í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

```rust
use std::rc::Rc;

let a = Rc::new([1, 2, 3]);
let b = a.clone();

assert_eq!(a.as_ptr(), b.as_ptr()); // Same allocation!
```

ìœ„ ì˜ˆì œì—ì„œëŠ” `Rc`íƒ€ì…ì˜ ë³€ìˆ˜ `a`ë¥¼ `clone()` ë©”ì†Œë“œë¡œ ë³µì‚¬í•´ì„œ `b`ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ë‘ ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ í™•ì¸í•´ë³´ë©´ ë™ì¼í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`Rc`ê°€ ì‚­ì œë˜ë©´ ì¹´ìš´í„°ê°€ ê°ì†Œë©ë‹ˆë‹¤. ê°€ì¥ ë§ˆì§€ë§‰ìœ¼ë¡œ ì¡´ì¬í•˜ëŠ” `Rc`ê°€ ì‚­ì œë˜ë©´, ì¹´ìš´í„°ê°€ 0ì´ ë˜ê³  ë”°ë¼ì„œ ë©”ëª¨ë¦¬ì—ì„œ ê°’ì´ í• ë‹¹ í•´ì œë©ë‹ˆë‹¤.

í•˜ì§€ë§Œ `Rc`ë¥¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ë³´ë‚´ë ¤ê³  í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.

```
    error[E0277]: `Rc` cannot be sent between threads safely
        |
    8   |     thread::spawn(move || dbg!(b));
        |                   ^^^^^^^^^^^^^^^
```

ê²°ë¡ ì ìœ¼ë¡œ `Rc`ëŠ” ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì´ ë³´ì¥ë˜ì§€ ì•ŠëŠ” íƒ€ì…ì…ë‹ˆë‹¤. ë§Œì¼ ì—¬ëŸ¬ ê°œì˜ ìŠ¤ë ˆë“œê°€ íŠ¹ì • ê°’ì— ëŒ€í•´ `Rc`ë¥¼ ì‚¬ìš©í•œë‹¤ë©´, ê° ìŠ¤ë ˆë“œì—ì„œ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ë™ì‹œì— ë³€ê²½í•  ê°€ëŠ¥ì„±ì´ ìˆê³  ì´ê²ƒì€ ì˜ˆì¸¡í•˜ì§€ ëª»í•œ ê²°ê³¼ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.



### Arc(Atomic refernce counting)

ëŒ€ì‹  ì•„í† ë¯¹(atomically)í•œ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…ì„ ì‚¬ìš©í•˜ëŠ” `std::sync::Arc`ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `Rc`ì™€ ë™ì¼í•œ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ, `Arc`ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒì´ í—ˆìš©ëœë‹¤ëŠ” ì ì´ ë‹¤ë¦…ë‹ˆë‹¤. ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë³€ê²½ë˜ëŠ” ì‘ì—…ì´ ì•„í† ë¯¹í•˜ê²Œ ì´ë£¨ì–´ì§€ê¸° ë•Œë¬¸ì—, ì—¬ëŸ¬ ê°œì˜ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ì¹´ìš´í„°ë¥¼ ë³€ê²½í•˜ë”ë¼ë„ ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì´ ë³´ì¥ë©ë‹ˆë‹¤.

```rust
use std::sync::Arc;

let a = Arc::new([1, 2, 3]);
let b = a.clone();

thread::spawn(move || dbg!(a));
thread::spawn(move || dbg!(b));
```

- (1)ì—ì„œ ë°°ì—´ì„ `Arc`ë¥¼ ì‚¬ìš©í•´ ë©”ëª¨ë¦¬ì— í• ë‹¹í•©ë‹ˆë‹¤. ì´ë•Œ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” 1ì´ ë©ë‹ˆë‹¤.
- `Arc`ë¥¼ í´ë¡ í•˜ë©´ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŠ¸ëŠ” 2ê°€ ë˜ê³ , `a`ì™€ `b` ëª¨ë‘ ê°™ì€ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ê³ ìœ í•œ `Arc`ë¥¼ ì „ë‹¬ë°›ì•˜ìŠµë‹ˆë‹¤. ì¦‰ ë°°ì—´ì´ ìŠ¤ë ˆë“œ ì‚¬ì´ì— ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤. ê° ìŠ¤ë ˆë“œì—ì„œ `Arc`ê°€ ì‚­ì œë  ë•Œë§ˆë‹¤ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ê°ì†Œí•˜ê³ , ì¹´ìš´í„°ê°€ 0ì´ ë˜ë©´ ë°°ì—´ì€ ë©”ëª¨ë¦¬ì—ì„œ í• ë‹¹ í•´ì œë©ë‹ˆë‹¤.



## ë®¤í…ìŠ¤(mutex)

ë®¤í…ìŠ¤ëŠ” Mutual exclusion(ìƒí˜¸ ë°°ì œ)ì˜ ì•½ìë¡œ, ë®¤í…ìŠ¤ëŠ” ì£¼ì–´ì§„ ì‹œê°„ì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•©ë‹ˆë‹¤. ë®¤í…ìŠ¤ì˜ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ë©´ ë¨¼ì € ìŠ¤ë ˆë“œê°€ ë®¤í…ìŠ¤ì˜ ë½(lock)ì„ íšë“í•˜ë„ë¡ ìš”ì²­í•˜ì—¬ ì•¡ì„¸ìŠ¤ë¥¼ ì›í•œë‹¤ëŠ” ì‹ í˜¸ë¥¼ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤. ë½ì€ ë®¤í…ìŠ¤ì˜ ì¼ë¶€ì¸ ë°ì´í„° êµ¬ì¡°ë¡œ, ì–´ë–¤ ìŠ¤ë ˆë“œì—ì„œ ë®¤í…ìŠ¤ë¥¼ ì°¸ì¡°í•˜ê³  ìˆëŠ”ì§€ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë‘ ê°€ì§€ ê·œì¹™ì„ ì§€ì¼œì•¼ í•©ë‹ˆë‹¤.

- ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì— ë°˜ë“œì‹œ ì ê¸ˆì„ í•´ì œí•´ì•¼ í•©ë‹ˆë‹¤.
- ë®¤í…ìŠ¤ê°€ ë³´í˜¸í•˜ëŠ” ë°ì´í„°ë¥¼ ì‚¬ìš©í•œ í›„ì—ëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ê¸ˆì„ íšë“í•  ìˆ˜ ìˆë„ë¡ ë°ì´í„°ì˜ ì ê¸ˆì„ í•´ì œí•´ì•¼ í•©ë‹ˆë‹¤.



#### ë®¤í…ìŠ¤ì˜ API

ë®¤í…ìŠ¤ ì‚¬ìš© ë°©ë²•ì„ ì‚´í´ë³´ê¸° ìœ„í•´ ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}

```

ì‹¤í–‰ ê²°ê³¼

```
m = Mutex { data: 6, poisoned: false, .. }
```

ë§ì€ íƒ€ì…ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ, ì—°ê´€ í•¨ìˆ˜ newë¥¼ ì‚¬ìš©í•´ Mutexë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ë®¤í…ìŠ¤ ë‚´ë¶€ì˜ ë°ì´í„°ì— ì ‘ê·¼í•˜ê¸° ìœ„í•´ `lock` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ ë½ì„ íšë“í•©ë‹ˆë‹¤. ì´ í˜¸ì¶œì€ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•˜ì—¬ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ë½ì„ ê°€ì§ˆ ì°¨ë¡€ê°€ ë  ë•Œê¹Œì§€ ì–´ë–¤ ì‘ì—…ë„ í•  ìˆ˜ ì—†ë„ë¡ í•©ë‹ˆë‹¤.

> ë§Œì•½ ë½ì„ ë³´ìœ í•œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ íŒ¨ë‹‰ì— ë¹ ì§€ë©´ `lock` í˜¸ì¶œì´ ì‹¤íŒ¨í•©ë‹ˆë‹¤. ì´ ê²½ìš° ì•„ë¬´ë„ ë½ì„ ì–»ì„ ìˆ˜ ì—†ê²Œ ë˜ê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œì—ì„œ íŒ¨ë‹‰ì„ ë°œìƒì‹œí‚µë‹ˆë‹¤.

ë½ì„ íšë“í•œ í›„ì—ëŠ” ë°˜í™˜ ê°’(ì´ ê²½ìš° num)ì„ ë®¤í…ìŠ¤ ë‚´ë¶€ì˜ ê°’ì— ëŒ€í•œ ê°€ë³€ ë ˆí¼ëŸ°ìŠ¤ë¡œ ì·¨ê¸‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë½ì„ í•´ì œí•˜ê³  ë‚˜ì„œ ë®¤í…ìŠ¤ì˜ ê°’ì„ ì¶œë ¥í•˜ë©´ ë‚´ë¶€ì— ë³´ê´€í•˜ê³  ìˆë˜ ì •ìˆ˜í˜• ê°’ì´ 5ì—ì„œ 6ìœ¼ë¡œ ë³€ê²½ëœ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.





balanceê°€ ì¸ì¶œí•˜ê³ ì í•˜ëŠ” ê¸ˆì•¡ë³´ë‹¤ í¬ë‹¤ê³  íŒë‹¨í•´ ì”ê³ ë¥¼ ì¸ì¶œí•©ë‹ˆë‹¤.

```python
import threading
import time

balance = 100

def withdraw(amount):
    global balance
    if balance >= amount:
        time.sleep(0.01)
        balance -= amount
        print(f"Withdrawal successful. Balance: {balance}")
    else:
        print("Insufficient balance.")

def main():
    t1 = threading.Thread(target=withdraw, args=(50,))
    t2 = threading.Thread(target=withdraw, args=(75,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()

if __name__ == '__main__':
    main()
```

ì‹¤í–‰ ê²°ê³¼

```python
Withdrawal successful. Balance: 50
Withdrawal successful. Balance: -25
```

ìŠ¤ë ˆë“œê°€ lockì„ íšë“í–ˆì„ ë•Œë§Œ ë°ì´í„°ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•˜ë©´ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
import time
import threading

balance = 100
lock = threading.Lock()

def withdraw(amount):
    global balance
    thread_id = threading.get_ident()
    with lock:
        print(f"Thread {thread_id}: Checking balance...")
        if balance >= amount:
            time.sleep(1)
            balance -= amount
            print(f"Thread {thread_id}: Withdrawal successful. Balance: {balance}")
        else:
            print(f"Thread {thread_id}: Insufficient balance.")

def check_lock():
    while lock.locked():
        print("Lock is locked.")
        time.sleep(0.1)

def main():
    t1 = threading.Thread(target=withdraw, args=(50,))
    t2 = threading.Thread(target=withdraw, args=(75,))
    t3 = threading.Thread(target=check_lock)
    t1.start()
    t2.start()
    t3.start()
    t1.join()
    t2.join()
    t3.join()

if __name__ == '__main__':
    main()
```

ì‹¤í–‰ ê²°ê³¼

```python
Thread 123145503645696: Checking balance...
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Thread 123145503645696: Withdrawal successful. Balance: 50
Thread 123145520435200: Checking balance...
Thread 123145520435200: Insufficient balance.
```





ë‹¤ìŒ ì½”ë“œëŠ” 10ê°œì˜ ìŠ¤ë ˆë“œê°€ 100ë²ˆì”© 1ì”© ì¦ê°€í•˜ëŠ” ê°’ì„ ë”í•˜ëŠ” ì½”ë“œì…ë‹ˆë‹¤. 

```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn withdraw(balance: &mut i32, amount: i32) {
    if *balance >= amount {
        thread::sleep(Duration::from_millis(10));
        *balance -= amount;
        println!("Withdrawal successful. Balance: {balance}");
    } else {
        println!("Insufficient balance.");
    }
}

fn main() {
    let mut balance = Arc::new(100);

    let t1 = thread::spawn(move || {
        withdraw(&mut balance, 50); // ğŸ¤¯
    });

    let t2 = thread::spawn(move || {
        withdraw(&mut balance, 75);
    });

    t1.join().unwrap();
    t2.join().unwrap();
}

```

ê°€ë³€ ë ˆí¼ëŸ°ìŠ¤ë¡œ ê° ìŠ¤ë ˆë“œì— ê°’ì„ ì „ë‹¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.



ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•´ ë°ì´í„°ë¥¼ ë³´í˜¸í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë°ì´í„°ê°€ ë”í•´ì§€ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.


```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn withdraw(balance: Arc<Mutex<i32>>, amount: i32) {
    let mut balance = balance.lock().unwrap();
    println!("{:?}: Checking balance.", thread::current().id());
    if *balance >= amount {
        thread::sleep(Duration::from_millis(100));
        *balance -= amount;
        println!("Withdrawal successful. Balance: {balance}");
    } else {
        println!("Insufficient balance.");
    }
}

fn check_lock(balance: Arc<Mutex<i32>>) {
    while let Err(_) = balance.try_lock() {
        println!("Lock is locked.");
        thread::sleep(Duration::from_millis(10));
    }
}

fn main() {
    let balance = Arc::new(Mutex::new(100));

    let balance1 = Arc::clone(&balance);
    let t1 = thread::spawn(move || {
        withdraw(Arc::clone(&balance1), 50);
    });
    let balance2 = Arc::clone(&balance);
    let t2 = thread::spawn(move || {
        withdraw(Arc::clone(&balance2), 75);
    });
    let balance3 = Arc::clone(&balance);
    let t3 = thread::spawn(move || {
        check_lock(Arc::clone(&balance3));
    });

    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
}

```

ì‹¤í–‰ ê²°ê³¼

```
ThreadId(2): Checking balance.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Lock is locked.
Withdrawal successful. Balance: 50
ThreadId(3): Checking balance.
Insufficient balance.
```

