## `RefCell<T>`

### `Rc<T>`ì˜ í•œê³„

Rc<T>ë¥¼ ì‚¬ìš©í•˜ë©´ í”„ë¡œê·¸ë¨ì˜ ì—¬ëŸ¬ ë¶€ë¶„ì—ì„œ ì½ê¸° ì „ìš©ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ Rc<T>ê°€ ë¶ˆë³€ ë ˆí¼ëŸ°ìŠ¤ë¥¼ í†µí•´ ê°’ì„ ê³µìœ í•˜ê¸° ë•Œë¬¸ì—, ê³µìœ ë°›ì€ ê°’ì„ ë³€ê²½í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì‹œë¥¼ ì‚´í´ë´…ì‹œë‹¤.

```rust
use std::rc::Rc;

struct Owner {
    name: String,
    tools: Rc<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

pub fn main() {
    let indo = Rc::new(Owner {
        name: "indo".to_string(),
        tools: Rc::new(vec![]),
    });
    let pliers = Rc::new(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::new(Tool {
        owner: indo.clone(),
    });

    indo.tools.push(Rc::clone(&pliers)); // ğŸ¤¯
    indo.tools.push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```

ì‹¤í–‰ ê²°ê³¼

```
error[E0596]: cannot borrow data in an `Rc` as mutable
  --> src/main.rs:24:5
   |
24 |     brad.tools.push(Rc::clone(&pliers)); // ğŸ¤¯
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable
   |

...
```







```rust
use std::{cell::RefCell, rc::Rc};

struct Owner {
    name: String,
    tools: RefCell<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

pub fn main() {
    let indo = Rc::from(Owner {
        name: "indo".to_string(),
        tools: RefCell::new(vec![]),
    });
    let pliers = Rc::from(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::from(Tool {
        owner: indo.clone(),
    });

    indo.tools.borrow_mut().push(Rc::clone(&pliers));
    indo.tools.borrow_mut().push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.borrow().iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```



### ë‚´ë¶€ ê°€ë³€ì„±(Interiror mutability)

`RefCell<T>`ê°€ ë¶ˆë³€ì´ì–´ë„ ë‚´ë¶€ì˜ ê°’ì€ ê°€ë³€ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥

```rust
indo.tools.borrow_mut().push(Rc::clone(&pliers));
```

ë¶ˆë³€ ì†Œìœ ê¶Œ ëŒ€ì—¬ë„ ê°€ëŠ¥

``` rust
indo.tools.borrow().iter()
```



### ì†Œìœ ê¶Œ ê·œì¹™

- ì—¬ëŸ¬ ë²ˆ ë¹Œë ¤ë„ ê´œì°®ìŠµë‹ˆë‹¤
- í•œ ë²ˆ ë¹Œë¦¬ëŠ” ê²ƒë„ ê´œì°®ìŠµë‹ˆë‹¤
- í•˜ì§€ë§Œ ê°€ë³€ê³¼ ë¶ˆë³€ì´ ëŒ€ì—¬ëŠ” ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤

ëŸ°íƒ€ì„ ì‹œê°„ì— ì†Œìœ ê¶Œì´ í™•ì¸ë˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ë˜ì§€ë§Œ ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒ

```rust
use std::{cell::RefCell, rc::Rc};

struct Owner {
    name: String,
    tools: RefCell<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

pub fn main() {
    let indo = Rc::from(Owner {
        name: "indo".to_string(),
        tools: RefCell::new(vec![]),
    });
    let pliers = Rc::from(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::from(Tool {
        owner: indo.clone(),
    });

    let mut borrow_mut_tools1 = indo.tools.borrow_mut();
    let mut borrow_mut_tools2 = indo.tools.borrow_mut(); // ğŸ¤¯
    borrow_mut_tools1.push(Rc::clone(&pliers));
    borrow_mut_tools2.push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.borrow().iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```

ì‹¤í–‰ ê²°ê³¼

```
thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:25:44
```



### `Rc<RefCell<T>>`

`RefCell<T>`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì€ `Rc<T>`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. `Rc<T>`ë¥¼ ì‚¬ìš©í•˜ë©´ ì¼ë¶€ ë°ì´í„°ì˜ ì†Œìœ ìë¥¼ ì—¬ëŸ¬ ëª… ê°€ì§ˆ ìˆ˜ ìˆì§€ë§Œ, í•´ë‹¹ ë°ì´í„°ì— ëŒ€í•œ ë¶ˆë³€ ì•¡ì„¸ìŠ¤ ê¶Œí•œë§Œ ë¶€ì—¬í•œë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”. `RefCell<T>`ë¥¼ ë³´ìœ í•œ `Rc<T>`ê°€ ìˆë‹¤ë©´, ì—¬ëŸ¬ ì†Œìœ ìë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³  ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

ìš”ì•½í•˜ìë©´, RcëŠ” ê³µìœ  ì†Œìœ ê¶Œì„ ì œê³µí•©ë‹ˆë‹¤. ë‚´ë¶€ ê°’ì—ëŠ” ì—¬ëŸ¬ ì†Œìœ ìê°€ ìˆìœ¼ë©°, ì°¸ì¡° ì¹´ìš´íŒ…ì€ ì ì–´ë„ í•œ ëª…ì˜ ì†Œìœ ìê°€ ë°ì´í„°ë¥¼ ê³„ì† ë³´ìœ í•˜ê³  ìˆëŠ” í•œ ë°ì´í„°ê°€ ê³„ì† ìœ ì§€ë˜ë„ë¡ í•©ë‹ˆë‹¤. ì´ëŠ” ë°ì´í„° ì†Œìœ ìê°€ ëª…í™•í•˜ì§€ ì•Šì€ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤. RefCellì€ ë‚´ë¶€ ê°€ë³€ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. ì¦‰, ëŸ°íƒ€ì„ì— ë‚´ë¶€ ê°’ì„ ë™ì ìœ¼ë¡œ ë¹Œë¦´ ìˆ˜ ìˆê³  ê³µìœ  ì°¸ì¡°ë¥¼ í†µí•´ì„œë„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Rc<RefCell<...>> ì¡°í•©ì€ ì†Œìœ ìê°€ ì—¬ëŸ¬ ëª…ì¸ ê°’ì„ ì†Œìœ ì ì¤‘ í•œ ëª…ì´ ê°€ë³€ì ìœ¼ë¡œ ë¹Œë¦´ ìˆ˜ ìˆëŠ” ë‘ ê°€ì§€ì˜ ì¡°í•©ì„ ì œê³µí•©ë‹ˆë‹¤.



### ì–¸ì œ ë¬´ì—‡ì„

|                  | `Box<T>`                               | `Rc<T>`                                             | `RefCell<T>`                                             |
| ---------------- | -------------------------------------- | --------------------------------------------------- | -------------------------------------------------------- |
| ì†Œìœ ê¶Œ           | í•œ ê°œ                                  | í•œ ê°œë¥¼ ê³µìœ                                         | í•œ ê°œ                                                    |
| ì†Œìœ ê¶Œ í™•ì¸ ì‹œì  | ë¶ˆë³€/ê°€ë³€ ì†Œìœ ê¶Œì„ ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¸  | ë¶ˆë³€ ì†Œìœ ê¶Œì„ ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¸                    | ë¶ˆë³€/ê°€ë³€ ì†Œìœ ê¶Œì„ ëŸ°íƒ€ì„ì— í™•ì¸                         |
| íŠ¹ì§•             | ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ ë ˆí¼ëŸ°ìŠ¤ë„ ëª¨ë‘ ì‚­ì œ | ë ˆí¼ëŸ°ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë„ ê°’ì´ ìœ ì§€ë¨ | `RefCell<T>`ê°€ ë¶ˆë³€ì´ì–´ë„ ë‚´ë¶€ì˜ ê°’ì€ ê°€ë³€ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥ |



> RefCell<T>ëŠ” ë©€í‹°ìŠ¤ë ˆë“œ ì½”ë“œì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”! Mutex<T>ëŠ” ìŠ¤ë ˆë“œì— ì•ˆì „í•œ RefCell<Tì˜ ë²„ì „ì´ë©°, Mutex<Tì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.





### Quiz



```rust
use std::fmt::Display;
use std::vec::Vec;

#[derive(Debug)]
struct Node<T> {
    data: T,
    children: Vec<Node<T>>,
}

impl<T: Display> Node<T> {
    fn new(data: T) -> Node<T> {
        Node {
            data,
            children: Vec::new(),
        }
    }

    fn depth_first(&self) {
        println!("{}", self.data);
        for child in self.children.iter() {
            child.depth_first();
        }
    }
}

fn main() {
    let mut a = Node::new('A');
    let mut b = Node::new('B');
    let c = Node::new('C');
    let d = Node::new('D');

    b.children.push(d);
    a.children.push(b);
    a.children.push(c);

    a.depth_first();
}

```



```rust
  fn add_child(&mut self, child: Wrapper<Node<T>>) {
      self.children.push(child);
  }
```



```rust
fn main() {
    let a = wrap(Node::new('A'));
    let b = wrap(Node::new('B'));
    let c = wrap(Node::new('C'));
    let d = wrap(Node::new('D'));

    a.borrow_mut().add_child(Rc::clone(&b));
    a.borrow_mut().add_child(Rc::clone(&c));
    b.borrow_mut().add_child(Rc::clone(&d));
    a.borrow_mut().depth_first();
}
```







 ì •ë‹µ

```rust
use std::cell::RefCell;
use std::fmt::Display;
use std::rc::Rc;
use std::vec::Vec;

type Wrapper<T> = Rc<RefCell<T>>;

fn wrap<T>(data: T) -> Wrapper<T> {
    Rc::new(RefCell::new(data))
}

#[derive(Debug)]
struct Node<T> {
    data: T,
    children: Vec<Wrapper<Node<T>>>,
}

impl<T: Display> Node<T> {
    fn add_child(&mut self, child: Wrapper<Node<T>>) {
        self.children.push(child);
    }

    fn new(data: T) -> Node<T> {
        Node {
            data,
            children: Vec::new(),
        }
    }

    fn depth_first(&self) {
        println!("node {}", self.data);
        for child in self.children.iter() {
            child.borrow().depth_first();
        }
    }
}

fn main() {
    let a = wrap(Node::new('A'));
    let b = wrap(Node::new('B'));
    let c = wrap(Node::new('C'));
    let d = wrap(Node::new('D'));

    a.borrow_mut().add_child(Rc::clone(&b));
    a.borrow_mut().add_child(Rc::clone(&c));
    b.borrow_mut().add_child(Rc::clone(&d));
    a.borrow_mut().depth_first();
}

```

