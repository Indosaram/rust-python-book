---
marp: true
paginate: true
theme: default
---

# íŒŒì´ì¬ í”„ë¡œê·¸ë˜ë¨¸ë¥¼ ìœ„í•œ ëŸ¬ìŠ¤íŠ¸ ì…ë¬¸

ìœ¤ì¸ë„
freedomzero91@gmail.com

---

# CH11. ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°

---

## í¬ì¸í„°ë€?

í¬ì¸í„°ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ í¬í•¨í•˜ëŠ” ë³€ìˆ˜ì…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì—ì„œ ê°€ì¥ ì¼ë°˜ì ì¸ ì¢…ë¥˜ì˜ í¬ì¸í„°ëŠ” ë ˆí¼ëŸ°ìŠ¤ì…ë‹ˆë‹¤.

## ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ë€?

ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ëŠ” í¬ì¸í„°ì²˜ëŸ¼ ì‘ë™í•˜ì§€ë§Œ, ë ˆí¼ëŸ°ìŠ¤ì˜ ê°œìˆ˜ ë“±ì„ í¬í•¨í•˜ê³  ìˆëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

---

## Box íƒ€ì…

### ë§Œì¼ ì–´ë–¤ íƒ€ì…ì˜ í¬ê¸°ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ë¯¸ë¦¬ ì•Œ ìˆ˜ ì—†ë‹¤ë©´?

ìê¸° ìì‹ ì„ í•„ë“œê°’ì˜ íƒ€ì…ìœ¼ë¡œ ê°–ëŠ” ì¬ê·€ í˜•íƒœì˜ êµ¬ì¡°ì²´(Recursive type)ë¥¼ ì •ì˜í•´ ë³´ê² ìŠµë‹ˆë‹¤.

---

```rust
struct Node {
    value: i32,
    next: Option<Node>,
}

fn main() {
    let mut head = Node {
        value: 1,
        next: None,
    };
    head.next = Some(Node {
        value: 2,
        next: None,
    });
    println!("{}", head.value);
}

```

---

`Box` ë¥¼ ì‚¬ìš©í•˜ë¼ê³  í•¨

```rust
struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

fn main() {
    let mut head = Node {
        value: 1,
        next: None,
    };
    head.next = Some(Box::new(Node {
        value: 2,
        next: None,
    }));
    println!("{}", head.value);
}

```

---

## `Box<T>`

`Box`ê°€ ëŒ€ì²´ ë¬´ì—‡ì¼ê¹Œ?

`Box`ë¥¼ ì‚¬ìš©í•˜ë©´ ìŠ¤íƒì´ ì•„ë‹Œ í™ì— ë°ì´í„°ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¤íƒì— ë‚¨ëŠ” ê²ƒì€ í™ ë°ì´í„°ì— ëŒ€í•œ í¬ì¸í„°ì…ë‹ˆë‹¤.

---

### Box<T> ì‚¬ìš©í•˜ê¸°

ì•„ë˜ ì˜ˆì œëŠ” `Box`ë¥¼ ì‚¬ìš©í•˜ì—¬ `i32` ê°’ì„ í™ì— ì €ì¥í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

```rust
fn main() {
    let my_box = Box::new(5);
    println!("my_box = {}", my_box);
}

```

ìŠ¤ì½”í”„ ë§ˆì§€ë§‰ì— `my_box` ì—­ì‹œ ì‚­ì œë¨

---

`Box`ëŠ” ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

- ì»´íŒŒì¼ ì‹œ í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì… ë‚´ë¶€ì˜ ê°’ì— ì ‘ê·¼í•´ì•¼ í•˜ëŠ” ê²½ìš°
- í¬ê¸°ê°€ í° ê°’ì˜ ì†Œìœ ê¶Œì„ ì´ì „í•˜ê³  ì‹¶ì§€ë§Œ, ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ìœ„í•´ ì „ì²´ ê°’ì´ ë³µì‚¬ë˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•˜ëŠ” ê²½ìš°
- íŠ¹ì • íƒ€ì…ì´ ì•„ë‹Œ, íŠ¹ì • íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì˜ ë³€ìˆ˜ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ê³  ì‹¶ì€ ê²½ìš°

ì²« ë²ˆì§¸ ìƒí™©ì€ ìœ„ì—ì„œ ì´ë¯¸ ì‚´í´ë³¸ `Node`ì˜ ê²½ìš°ì…ë‹ˆë‹¤. ì´ì œ ë‚˜ë¨¸ì§€ ê°ê°ì˜ ê²½ìš°ë¥¼ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

---

### ì†Œìœ ê¶Œì„ íš¨ìœ¨ì ìœ¼ë¡œ ì „ë‹¬í•˜ê¸°

ë ˆí¼ëŸ°ìŠ¤ ëŒ€ì‹ 

```rust
fn transfer_box(_data: Box<Vec<i32>>) {}

fn transfer_vec(_data: Vec<i32>) {}

fn main() {
    let data = vec![0; 10_000_000];

    transfer_vec(data.clone());

    let boxed = Box::new(data);
    transfer_box(boxed);
}

```

---

### `dyn` ê³¼ `Box`ë¡œ íŠ¸ë ˆì´íŠ¸ íƒ€ì… í‘œí˜„í•˜ê¸°

```bash
cargo add rand
```

---

```rust
struct Dog {}
struct Cat {}

trait Animal {
    fn noise(&self) -> &'static str;
}

impl Animal for Dog {
    fn noise(&self) -> &'static str {
        "ğŸ¶ë©ë©!"
    }
}

impl Animal for Cat {
    fn noise(&self) -> &'static str {
        "ğŸ±ì•¼ì˜¹!"
    }
}

```

---

```rust

fn random_animal() -> impl Animal {
    if rand::random::<f64>() < 0.5 {
        Dog {}
    } else {
        Cat {}
    }
}

fn main() {
    for _ in 0..10 {
        println!("{}", random_animal().noise());
    }
}

```

---

```
error[E0308]: `if` and `else` have incompatible types
  --> src/main.rs:24:9
   |
21 | /     if rand::random::<f64>() < 0.5 {
22 | |         Dog {}
   | |         ------ expected because of this
23 | |     } else {
24 | |         Cat {}
   | |         ^^^^^^ expected struct `Dog`, found struct `Cat`
25 | |     }
   | |_____- `if` and `else` have incompatible types
   |
help: you could change the return type to be a boxed trait object
   |
20 | fn random_animal() -> Box<dyn Animal> {
   |                       ~~~~~~~       +
help: if you change the return type to expect trait objects,
box the returned expressions
   |
22 ~         Box::new(Dog {})
23 |     } else {
24 ~         Box::new(Cat {})
   |
```

---

```rust
fn random_animal() -> Box<dyn Animal> {
    if rand::random::<f64>() < 0.5 {
        Box::new(Dog {})
    } else {
        Box::new(Cat {})
    }
}
```

---

ì‹¤í–‰ ê²°ê³¼

```
ğŸ±ì•¼ì˜¹!
ğŸ¶ë©ë©!
ğŸ¶ë©ë©!
ğŸ¶ë©ë©!
ğŸ±ì•¼ì˜¹!
ğŸ±ì•¼ì˜¹!
ğŸ¶ë©ë©!
ğŸ¶ë©ë©!
ğŸ¶ë©ë©!
ğŸ¶ë©ë©!
```

---

## `Rc<T>`

ë§Œì¼ í•˜ë‚˜ì˜ ê°’ì— ì—¬ëŸ¬ ê°œì˜ ì†Œìœ ìë¥¼ ì •ë§ë¡œ ê°€ì§€ê³  ì‹¶ë‹¤ë©´ ì–´ë–»ê²Œ í• ê¹Œìš”? ì´ëŸ´ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìë£Œí˜•ì´ ë°”ë¡œ `Rc<T>`ì…ë‹ˆë‹¤. ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…(Reference counting)ì˜ ì• ìë¥¼ ë”°ì„œ ë§Œë“  ì´ë¦„ìœ¼ë¡œ, `Rc<T>` ì—­ì‹œ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì…ë‹ˆë‹¤.

---

ì¼ë°˜ì ì¸ ë ˆí¼ëŸ°ìŠ¤ì²˜ëŸ¼ ë””ë ˆí¼ëŸ°ìŠ¤í•´ì„œ ì‚¬ìš© ê°€ëŠ¥

```rust
use std::rc::Rc;

fn main() {
    let origin = Rc::new(1);

    assert_eq!(1, *origin);
}

```

---

### ë§ˆì§€ë§‰ ìˆœê°„ê¹Œì§€

í”„ë¡œê·¸ë¨ì˜ ì—¬ëŸ¬ ë¶€ë¶„ì´ ì½ì„ ìˆ˜ ìˆë„ë¡ í™ì— ì¼ë¶€ ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê³  ì»´íŒŒì¼ ì‹œì ì— ì–´ëŠ ë¶€ë¶„ì´ ë°ì´í„°ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©í• ì§€ ê²°ì •í•  ìˆ˜ ì—†ì„ ë•Œ `Rc<T>` íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

---

```rust
fn main() {
    let cloned;
    {
        let origin = "Rust".to_string();
        cloned = &origin; // ğŸ¤¯
    }
    println!("{}", cloned);
}

```

---

```rust
use std::rc::Rc;

fn main() {
    let cloned;
    {
        let origin = Rc::new(1);
        cloned = origin.clone();
    }
    println!("{}", cloned);
}

```

ì—¬ê¸°ì„œ `clone`ì„ ì‚¬ìš©í•˜ë©´, ì‹¤ì œë¡œ ê°’ì´ ë³µì‚¬ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ `Rc`ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŠ¸ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.

---

### ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…

`Rc<T>`ëŠ” ê°’ì˜ ì†Œìœ ê¶Œì„ ê°€ì§€ê³  ìˆëŠ” ë³€ìˆ˜ê°€ ëª‡ ê°œì¸ì§€ë¥¼ ê³„ì† í™•ì¸í•˜ê³  ìˆë‹¤ê°€, ê°’ì„ ì†Œìœ í•˜ê³  ìˆëŠ” ë³€ìˆ˜ê°€ ì „ë¶€ ì‚¬ë¼ì§€ë©´ ê°’ì„ ë©”ëª¨ë¦¬ì—ì„œ ì‚­ì œí•©ë‹ˆë‹¤.

---

```rust
use std::rc::Rc;

fn main() {
    let origin = Rc::new(0);
    println!("Reference count: {}", Rc::strong_count(&origin));
    {
        let _dup1 = Rc::clone(&origin);
        println!("Reference count: {}", Rc::strong_count(&origin));
        {
            let _dup2 = &origin.clone();
            println!("Reference count: {}", Rc::strong_count(&origin));
        }
        println!("Reference count: {}", Rc::strong_count(&origin));
    }
    println!("Reference count: {}", Rc::strong_count(&origin));
    // origin drops here
}

```

---

ì‹¤í–‰ ê²°ê³¼

```
Reference count: 1
Reference count: 2
Reference count: 3
Reference count: 2
Reference count: 1
```

---

> `Rc<T>`ëŠ” ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë™ì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œëŠ” `Arc<T>`ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ë©°, ìì„¸í•œ ë‚´ìš©ì€ ë‚˜ì¤‘ì— ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.

---

### Quiz

```rust
struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

fn main() {
    let mut head1 = Node {
        value: 1,
        next: None,
    };
    let node1 = Node {
        value: 2,
        next: None,
    };
    head1.next = Some(Box::new(node1));

    let mut head2 = Node {
        value: 3,
        next: None,
    };
    head2.next = Some(Box::new(node1)); // ğŸ¤¯

    println!("{} {}", head1.value, head1.next.unwrap().value);
    println!("{} {}", head2.value, head2.next.unwrap().value);
}

```

---

ì •ë‹µ

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    next: Option<Rc<Node>>,
}

fn main() {
    let mut head1 = Node {
        value: 1,
        next: None,
    };
    let node1 = Rc::new(Node {
        value: 2,
        next: None,
    });
    head1.next = Some(Rc::clone(&node1));

    let mut head2 = Node {
        value: 3,
        next: None,
    };
    head2.next = Some(Rc::clone(&node1));

    println!("{} {}", head1.value, head1.next.unwrap().value);
    println!("{} {}", head2.value, head2.next.unwrap().value);
}

```

---

## `RefCell<T>`

### `Rc<T>`ì˜ í•œê³„

Rc<T>ë¥¼ ì‚¬ìš©í•˜ë©´ í”„ë¡œê·¸ë¨ì˜ ì—¬ëŸ¬ ë¶€ë¶„ì—ì„œ ì½ê¸° ì „ìš©ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ Rc<T>ê°€ ë¶ˆë³€ ë ˆí¼ëŸ°ìŠ¤ë¥¼ í†µí•´ ê°’ì„ ê³µìœ í•˜ê¸° ë•Œë¬¸ì—, ê³µìœ ë°›ì€ ê°’ì„ ë³€ê²½í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì‹œë¥¼ ì‚´í´ë´…ì‹œë‹¤.

---

```rust
use std::rc::Rc;

struct Owner {
    name: String,
    tools: Rc<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

pub fn main() {
    let indo = Rc::new(Owner {
        name: "indo".to_string(),
        tools: Rc::new(vec![]),
    });
    let pliers = Rc::new(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::new(Tool {
        owner: indo.clone(),
    });

    indo.tools.push(Rc::clone(&pliers)); // ğŸ¤¯
    indo.tools.push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```

---

ì‹¤í–‰ ê²°ê³¼

```
error[E0596]: cannot borrow data in an `Rc` as mutable
  --> src/main.rs:24:5
   |
24 |     brad.tools.push(Rc::clone(&pliers)); // ğŸ¤¯
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable
   |

...
```

---

```rust
use std::{cell::RefCell, rc::Rc};

struct Owner {
    name: String,
    tools: RefCell<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

pub fn main() {
    let indo = Rc::from(Owner {
        name: "indo".to_string(),
        tools: RefCell::new(vec![]),
    });
    let pliers = Rc::from(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::from(Tool {
        owner: indo.clone(),
    });

    indo.tools.borrow_mut().push(Rc::clone(&pliers));
    indo.tools.borrow_mut().push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.borrow().iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```

---

### ë‚´ë¶€ ê°€ë³€ì„±(Interiror mutability)

`RefCell<T>`ê°€ ë¶ˆë³€ì´ì–´ë„ ë‚´ë¶€ì˜ ê°’ì€ ê°€ë³€ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥

```rust
indo.tools.borrow_mut().push(Rc::clone(&pliers));
```

ë¶ˆë³€ ì†Œìœ ê¶Œ ëŒ€ì—¬ë„ ê°€ëŠ¥

```rust
indo.tools.borrow().iter()
```

---

### ì†Œìœ ê¶Œ ê·œì¹™

- ì—¬ëŸ¬ ë²ˆ ë¹Œë ¤ë„ ê´œì°®ìŠµë‹ˆë‹¤
- í•œ ë²ˆ ë¹Œë¦¬ëŠ” ê²ƒë„ ê´œì°®ìŠµë‹ˆë‹¤
- í•˜ì§€ë§Œ ê°€ë³€ê³¼ ë¶ˆë³€ì´ ëŒ€ì—¬ëŠ” ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤

ëŸ°íƒ€ì„ ì‹œê°„ì— ì†Œìœ ê¶Œì´ í™•ì¸ë˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ë˜ì§€ë§Œ ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒ

---

```rust
use std::{cell::RefCell, rc::Rc};

struct Owner {
    name: String,
    tools: RefCell<Vec<Rc<Tool>>>,
}

struct Tool {
    owner: Rc<Owner>,
}

```

---

```rust
pub fn main() {
    let indo = Rc::from(Owner {
        name: "indo".to_string(),
        tools: RefCell::new(vec![]),
    });
    let pliers = Rc::from(Tool {
        owner: Rc::clone(&indo),
    });
    let wrench = Rc::from(Tool {
        owner: indo.clone(),
    });

    let mut borrow_mut_tools1 = indo.tools.borrow_mut();
    let mut borrow_mut_tools2 = indo.tools.borrow_mut(); // ğŸ¤¯
    borrow_mut_tools1.push(Rc::clone(&pliers));
    borrow_mut_tools2.push(Rc::clone(&wrench));

    println!("Pliers owner: {}", pliers.owner.name);

    for tool in indo.tools.borrow().iter() {
        println!("Tool's owner: {:?}", tool.owner.name);
    }
}

```

---

ì‹¤í–‰ ê²°ê³¼

```
thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:25:44
```

---

### `Rc<RefCell<T>>`

`RefCell<T>`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì€ `Rc<T>`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. `Rc<T>`ë¥¼ ì‚¬ìš©í•˜ë©´ ì¼ë¶€ ë°ì´í„°ì˜ ì†Œìœ ìë¥¼ ì—¬ëŸ¬ ëª… ê°€ì§ˆ ìˆ˜ ìˆì§€ë§Œ, í•´ë‹¹ ë°ì´í„°ì— ëŒ€í•œ ë¶ˆë³€ ì•¡ì„¸ìŠ¤ ê¶Œí•œë§Œ ë¶€ì—¬í•œë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”. `RefCell<T>`ë¥¼ ë³´ìœ í•œ `Rc<T>`ê°€ ìˆë‹¤ë©´, ì—¬ëŸ¬ ì†Œìœ ìë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³  ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

---

### ì–¸ì œ ë¬´ì—‡ì„

|                  | `Box<T>`                               | `Rc<T>`                                             | `RefCell<T>`                                             |
| ---------------- | -------------------------------------- | --------------------------------------------------- | -------------------------------------------------------- |
| ì†Œìœ ê¶Œ           | í•œ ê°œ                                  | í•œ ê°œë¥¼ ê³µìœ                                         | í•œ ê°œ                                                    |
| ì†Œìœ ê¶Œ í™•ì¸ ì‹œì  | ë¶ˆë³€/ê°€ë³€ ì†Œìœ ê¶Œì„ ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¸  | ë¶ˆë³€ ì†Œìœ ê¶Œì„ ì»´íŒŒì¼ íƒ€ì„ì— í™•ì¸                    | ë¶ˆë³€/ê°€ë³€ ì†Œìœ ê¶Œì„ ëŸ°íƒ€ì„ì— í™•ì¸                         |
| íŠ¹ì§•             | ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ ë ˆí¼ëŸ°ìŠ¤ë„ ëª¨ë‘ ì‚­ì œ | ë ˆí¼ëŸ°ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë„ ê°’ì´ ìœ ì§€ë¨ | `RefCell<T>`ê°€ ë¶ˆë³€ì´ì–´ë„ ë‚´ë¶€ì˜ ê°’ì€ ê°€ë³€ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥ |

> RefCell<T>ëŠ” ë©€í‹°ìŠ¤ë ˆë“œ ì½”ë“œì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”! Mutex<T>ëŠ” ìŠ¤ë ˆë“œì— ì•ˆì „í•œ RefCell<Tì˜ ë²„ì „ì´ë©°, Mutex<Tì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.

---

### Quiz

```rust
use std::fmt::Display;
use std::vec::Vec;

#[derive(Debug)]
struct Node<T> {
    data: T,
    children: Vec<Node<T>>,
}

impl<T: Display> Node<T> {
    fn new(data: T) -> Node<T> {
        Node {
            data,
            children: Vec::new(),
        }
    }

    fn depth_first(&self) {
        println!("{}", self.data);
        for child in self.children.iter() {
            child.depth_first();
        }
    }
}

fn main() {
    let mut a = Node::new('A');
    let mut b = Node::new('B');
    let c = Node::new('C');
    let d = Node::new('D');

    b.children.push(d);
    a.children.push(b);
    a.children.push(c);

    a.depth_first();
}
```

---

ì•„ë˜ ë©”ì†Œë“œë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.

```rust
  fn add_child(&mut self, child: Wrapper<Node<T>>) {
      self.children.push(child);
  }
```

---

```rust
fn main() {
    let a = wrap(Node::new('A'));
    let b = wrap(Node::new('B'));
    let c = wrap(Node::new('C'));
    let d = wrap(Node::new('D'));

    a.borrow_mut().add_child(Rc::clone(&b));
    a.borrow_mut().add_child(Rc::clone(&c));
    b.borrow_mut().add_child(Rc::clone(&d));
    a.borrow_mut().depth_first();
}
```

---

ì •ë‹µ

```rust
use std::cell::RefCell;
use std::fmt::Display;
use std::rc::Rc;
use std::vec::Vec;

type Wrapper<T> = Rc<RefCell<T>>;

fn wrap<T>(data: T) -> Wrapper<T> {
    Rc::new(RefCell::new(data))
}

#[derive(Debug)]
struct Node<T> {
    data: T,
    children: Vec<Wrapper<Node<T>>>,
}

impl<T: Display> Node<T> {
    fn add_child(&mut self, child: Wrapper<Node<T>>) {
        self.children.push(child);
    }

    fn new(data: T) -> Node<T> {
        Node {
            data,
            children: Vec::new(),
        }
    }

    fn depth_first(&self) {
        println!("node {}", self.data);
        for child in self.children.iter() {
            child.borrow().depth_first();
        }
    }
}

fn main() {
    let a = wrap(Node::new('A'));
    let b = wrap(Node::new('B'));
    let c = wrap(Node::new('C'));
    let d = wrap(Node::new('D'));

    a.borrow_mut().add_child(Rc::clone(&b));
    a.borrow_mut().add_child(Rc::clone(&c));
    b.borrow_mut().add_child(Rc::clone(&d));
    a.borrow_mut().depth_first();
}

```
